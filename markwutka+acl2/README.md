# Fizzbuzz in ACL2

ACL2 is an applicative version of Common Lisp that contains a theorem
prover to prove statements about your code. ACL2 stands for "A Computational
Logic for Applicative Common Lisp".

As with other proof-oriented languages, ACL2 functions must terminate if
ACL2 is to prove anything about them. It is possible to define non-terminating
functions, but ACL2 cannot reason about them.

This implementation of Fizzbuzz defines 2 functions, the first generates
a single fizzbuzz value for some number n:

```lisp
(defun fizzbuzz1 (n)
  (if (equal 0 (mod n 3))
      (if (equal 0 (mod n 5)) "fizzbuzz" "fizz")
      (if (equal 0 (mod n 5)) "buzz" n)))
```

The fizzbuzz function then generates a list of n items with fizzbuzz1 values
from 1 to n:

```lisp
(defun fizzbuzz (n)
  (if (integerp n)
      (if (<= n 0) NIL
          (append (fizzbuzz (- n 1)) (list (fizzbuzz1 n))))
      NIL))
```

A reason for using ACL2 is that instead of writing unit tests, you write
proofs, so that for any value n, you can prove that (fizzbuzz n) produces
the correct list.

There are several proofs for each function, here is one for fizzbuzz1:

```lisp
(defthm fizzbuzz1-mod3
    (implies (and (equal 0 (mod n 3)) (not (equal 0 (mod n 5))))
         (equal (fizzbuzz1 n) "fizz")))
```

The idea here is that if n is divisible by 3, but not divisible by 5,
we prove that fizzbuzz1 will return "fizz" for n.

It is tricky to build a proof for fizzbuzz, but I think this works:

```lisp
(defthm fizzbuzz-list
    (implies (and (integerp n) (>= n 0)
                  (equal l (fizzbuzz n)))
         (equal (append l (list (fizzbuzz1 (+ n 1)))) (fizzbuzz (+ n 1)))))
```

This is an inductive proof, basically saying that for any list generated by
(fizzbuzz n), we prove that (fizzbuzz (+ n 1)) is the same as adding
(fizzbuzz1 (+ n 1)) to the (fizzbuzz n) list. 

